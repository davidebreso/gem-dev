GEM Developers' Kit - Pacific C libraries         John Elliott, 5 October 2002
==============================================================================

Version 1.0.2

  The list of new features in this release is at the end of this file.

  This is based on the GEM PTK version 3.1 downloadable from
<http://www.deltasoft.com>. The original (Lattice C) sample code has not been
included.

Installing
==========

  If you have GNU Make, edit MAKEDEFS.I to set the location of your Pacific
C installation, and type

     make install

  If not, the following library and include files need to be manually copied:

  Copy: LIB\*.LIB        to your Pacific C LIB directory.
  Copy: BIN\EXE2ACC .EXE to your Pacific C BIN directory, or somewhere on your
                         path.
  Copy: INCLUDE\*.H      to your Pacific C INCLUDE directory.

Overview of use
===============

  When writing your GEM application, add:

   $(LIB)\PPDGEM-S.LIB (small model)
or $(LIB)\PPDGEM-L.LIB (large model)

  to your project's "library files" list. To use GEM functions, you need only

#include "ppdgem.h"

  - this will include the other necessary files.

There are important differences between the PPD libraries and the Lattice C
libraries - see below.

  To create a Desk Accessory, run EXE2ACC after compiling:

     EXE2ACC filename.EXE filename.ACC 

  EXE2ACC needs access to the .SYM file generated by the linker.

Far pointers
============

  In the Lattice C libraries, all far pointers were cast to long integers;
this meant that pointer arithmetic had to be done by the programmer rather
than the compiler, and the portability macros had to be used instead of
direct access to structure members.

  In the Pacific C libraries, a number of true long pointer types have been
created using typedef:

LPVOID        - far pointer to void.
LPLPTR        - far pointer to a far void pointer.
LPBYTE        - far pointer to a byte. Cast to this type before
               performing explicit pointer arithmetic (involving sizeof).
LPWORD        - far pointer to a 16-bit signed word.
LPLONG        - far pointer to a 32-bit signed long.
LPUWORD       - far pointer to a 16-bit unsigned word.

LPOBJ, LPTREE - far pointer to an OBJECT structure or tree.
LPORECT       - far pointer to an ORECT structure.
LPGRECT       - far pointer to a  GRECT structure.
LPTEDI        - far pointer to a  TEDINFO structure.
LPICON        - far pointer to an ICONBLK structure.
LPBIT         - far pointer to a  BITBLK structure.
LPUSER        - far pointer to a  USERBLK structure.
LPPBLK        - far pointer to a  PPDUBLK structure (see "USERDEF" below).
LPAPPL        - far pointer to an APPLBLK structure.
LPPARM        - far pointer to a  PARMBLK structure.
LPMFDB        - far pointer to an MFDB structure.
LPFILL        - far pointer to a  FILLPAT structure.

The use of these types means that a lot of structure accesses and pointer
arithmetic can be delegated to the compiler. Compare the following code
fragments:

/* Before */

    VOID
do_obj(tree, which, bit)	/* set specified bit in object state	*/
    LONG	tree;
    WORD	which, bit;
{
	WORD	state;

	state = LWGET(OB_STATE(which));
	LWSET(OB_STATE(which), state | bit);
}

/* After */

VOID do_obj(LPTREE tree, WORD which, WORD bit)
{
	tree[which].ob_state |= bit;
}


Pitfalls
--------

  If you are working in the "small" memory model, problems may occur when
you are passing a local address to a routine requiring a far pointer - for
example (from DEMO.C):

VOID set_color(LPTREE tree,
               WORD obj,
               WORD color_num,
               LPVOID *bind)
{
/*CORRECT*/	set_select(tree, obj, color_num - 1, ADDR(bind), color_sel);
/*WRONG  *	set_select(tree, obj, color_num - 1,      bind , color_sel);*/
}

Here, bind is passed to set_color() as a near pointer, but must be passed to
set_select() as a far pointer. If ADDR() is not used to expand it, then the
far pointer version will contain the wrong segment address, leading to memory
corruption and crashes.

Memory models
=============

  Pacific C handles "large" and "small" memory models. Applications and
desk accessories can be built in either model.

* Since in the "large" model all pointers are far pointers, there is less
 chance of trouble with near-to-far pointer expansion. Also, C library
 functions can be used on far pointers.
* The "large" model generates larger and slower code.

Samples
=======

  The samples in the PPDSAMPL directory are Pacific C ports of the supplied
sample applications. The main() function simply checks for the GEM AES
before calling GEMAIN().
  The original GDK documentation states:

     3 - To link a GEM application (not a GEM accessory), you may use
     the startup program and library supplied by your compiler,  if you
     know that your compiler generates code to free memory not used by
     your program.

  I do not know whether Pacific C does this or not, but the sample
applications run.

  GEM allocates memory for desk accessories based on the size of the DA file.
EXE2ACC will increase the size of a DA file linked by Pacific C so that it
has sufficient memory available to it, and patch the initialisation code
so that the stack is put where it should be.

ViewMAX and FreeGEM
===================

  GEM was GPLed in April 1999; since then I have uploaded source for a
version (FreeGEM) containing the extra functions in ViewMAX/2 and ViewMAX/3.
The following functions apply to FreeGEM and ViewMAX:


     WORD xgrf_colour(WORD type, WORD fg, WORD bg, WORD style, WORD index);
     WORD xgrf_dtmfdb(LPMFDB newdesk);

  In xgrf_colour():

  type is the user interface object type, 0-15. The ones defined in
VIEWHELP.RSC are:
#define	CC_NAME		8         /* Active titlebar */
#define	CC_SLIDER	9         /* Scrollbar background */
#define	CC_DESKTOP	10        /* Desktop */
#define	CC_BUTTON	11        /* Buttons and 3D areas */
#define	CC_INFO		12        /* Information line */
#define	CC_ALERT	13        /* Alert boxes */
#define	CC_SLCTDNAME	14        /* Inactive titlebar */

Recent versions of FreeGEM add:

#define CC_3DSHADE	16        /* Foreground is 3D highlight &
                                     background is 3D shadow*/
#define CC_RADIO	17        /* Foreground & background colours of *
                                   * the dot in the radio button        */
#define CC_CHECK	18        /* Background is colour of tick */


  In xgrf_dtmfdb(), the first reserved word of the MFDB contains the
display mode for the image. It can be:

#define DT_CENTER	1         Centred
#define DT_TILE		2         Tiled


There are also five extra object flags:

#define ESCCANCEL 0x200           When applied to a button, ESC is a
                                  shortcut for it.
                                  You can make ESC a shortcut for a
                                  button in form_alert(), by passing the
                                  button number in the high byte of the
                                  'default button' parameter. For example,
                                  form_alert ((3 << 8) | 1, ...) means
                                  button 1 is the default button, and
                                  button 3 has ESC as the shortcut.
#define BITBUTTON 0x400           Not used by the AES.
#define SCROLLER 0x800            When applied to a button, it may intercept
                                  "up" or "down" arrow keypresses; used in
                                  list boxes.
#define FLAG3D 0x1000             Draw object in 3D. Buttons are always 3D.
#define USECOLOURCAT 0x2000       Use the system colours set by xgrf_colour().
                                  xgrf_color(). The object's colour value
                                  becomes the ViewMAX object type, as above.
                                  3D objects always use system colours.

Some FreeGEM versions also have:

#define FL3DBAK 0x4000            Make a "sunken" 3D object rather than a
                                  "raised" one.
#define SUBMENU 0x8000            Reserved - used in Atari GEM.

and two extra object states:

#define HIGHLIGHTED 0x100	  Draw a highlight box round the object
#define UNHIGHLIGHTED 0x200       Remove the highlight box

NOTE: The supplied RCS has been extended to handle the extra flags. This
is an experimental RCS - save early, save often and keep good backups!

  There is also one function only present in FreeGEM; it is:

WORD fsel_exinput(LPVOID pipath, LPVOID pisel, WORD *pbutton, LPBYTE ptitle);

  which behaves exactly as fsel_input(), but you can set the title of the
file selector. 

FreeGEM: Property file
======================

  There is a compile-time option in the latest GEM AES to include three
extra functions: prop_get(), prop_put() and prop_del() (nos. 1010-1012).
These are used to access a global settings file. The file currently has
an extremely simple structure, but the functions allow for a more
complicated tree-structured system.

  The syntax is:

  WORD prop_get(LPBYTE program, LPBYTE section, LPBYTE buf, WORD buflen,
                WORD options);

   "program" is a name that identifies your program. It should be formed of
  one or more words separated by dots - for example, the DEMO sample uses
  "PTK.DEMO". You should avoid program names starting "GEM." to avoid a clash
  with GEM itself.
   "section" is the name of the field to retrieve. Again, this should be
  one or more words separated by dots. DEMO uses "Pen.shade", "Pen.colour" and
  "Pen.size".
   "buf" is the address of the buffer to which the information will be
  written. 
   "buflen"  is the size of "buf", including the terminating 0.
   "options" should be 0 if the setting is per-user, 1 if it is for all
            users. This is for future expansion since GEM does not
            currently support multiple user profiles. It is recommended that
            "options" should be set to 0 if at all possible.

  This function returns:
  0 - Property read successfully.
  1 - Property was not found.
 -1 - File I/O error.
 -2 - Not enough memory to do this.

  WORD prop_put(LPBYTE program, LPBYTE section, LPBYTE buf, WORD options);

  The parameters and return values are as for prop_get() above, except
 that this function will never return 1. Note that prop_get() will remove
 leading spaces from returned values, so if you are writing a string value
 that may start with spaces, you must put it in quotes before calling
 prop_put().

  WORD prop_del(LPBYTE program, LPBYTE section, WORD options);

  The parameters are as for prop_get() above.

  The current property file format is an ASCII file: \GEMAPPS\GEMSYS\GEM.CFG.
 The "program" and "section" fields are concatenated to produce a single
 string, making each line look like:

      PTK.DEMO.Pen.size: 5
      PTK.DEMO.Pen.shade: 4
      PTK.DEMO.Pen.colour: 4

  You are strongly discouraged from allowing programs to edit this file
 directly!

FreeGEM: xapp_getinfo()
=======================

  This function is provided for compatibility with the Atari appl_getinfo()
function; you may call it as appl_getinfo() if you wish. The parameters and
results are all identical to the Atari version.

FreeGEM: xshl_getshell() and xshl_setshell()
============================================

  These functions are used to change the name of the shell program
(normally DESKTOP.APP).

  xshl_getshell() retrieves the program name (no path; the shell is always
in \GEMAPPS\GEMSYS). It returns 0 if the standard shell is in use, or 1
if the shell has been changed by xshl_setshell() or GEM.CFG
  xshl_setshell() sets the name of the shell (again, no path). It returns
0 if successful, 1 if the name was too long.

FreeGEM: Extra parameter to appl_init()
=========================================

  appl_init() now takes an extra parameter; a pointer to a structure of type
X_BUF_V2. If you don't want to use this parameter, pass NULL.

  To use the structure, fill it with zeroes and set its "buf_len" member to
its size. On return, if the program is running under FreeGEM, the remainder of
the structure will be filled with data:

typedef struct x_buf_v2
{
	WORD	buf_len;	/* Size of structure passed. Set by caller;
				 * on return, size of data returned by GEM */
	WORD	arch;	        /* 16 for 16-bit, 32 for any future 
				 * 32-bit version. 0 if not FreeGEM. */
	LPCCAT	cc;		/* Address of an array of 19 CLRCAT 
				 * structures.
                                 * This is so that they can be read by
                                 * a program without having to fiddle
                                 * with ViewMAX.INI */
	LPTREE	w_active;	/* Address of the tree (18 elements)
                                 * that is used to draw window frames and
                                 * controls. The intention is that the
                                 * glyphs on the buttons could be changed
                                 * by a program. This is now deprecated
                                 * in favour of using the window
                                 * decoration calls listed below */
	LPBYTE	info;		/* ASCII information such as a version 
				 * string. This will be max. 40 characters 
				 * with no newlines */
        LONG    abilities;      /* Bitmapped.
                                 * Bit 0 (ABLE_GETINFO) if the AES supports
                                 *       xapp_getinfo()
                                 * Bit 1 (ABLE_PROP)    if the AES supports
                                 *       prop_get(), prop_put(), prop_del()
                                 *       (compile-time option)
                                 * Bit 2 (ABLE_WTREE)   if the AES
                                 *       supports the window decoration
                                 *       calls listed below.
                                 * Bit 3 (ABLE_X3D)     if the AES
                                 *       supports the extended 3D flags
                                 *       listed below.
                                 * Bit 4 (ABLE_XSHL)    if the AES
                                 *       supports xshl_getshell() and
                                 *       xshl_setshell().
                                 * Bit 5 (ABLE_PROP2)   if the AES
                                 *       supports prop_gui_get() and
                                 *       prop_gui_set(). [XXX add these]
                                 * Bit 6 (ABLE_EMSDESK) The desktop image
                                 *       can be loaded into EMS memory
                                 * Bit 7 (ABLE_XBVSET)  if the AES supports
                                 *       32 disc drives rather than 16.
                                 */
} X_BUF_V2; 

typedef X_BUF_V2 FAR *LPXBUF;

FreeGEM: Window decorations
===========================

  The window decorations can be changed using wind_set() and wind_get(). This
is how:

#define WF_OBFLAG  1001	/* Window tree: flag words */
#define WF_OBTYPE  1002	/* Window tree: type words */
#define WF_OBSPEC  1003	/* Window tree: spec dwords */ 

  wind_get(n, WF_OBFLAG, &a, &b, &c, &d) - a = object flags for decoration "n"
  wind_get(n, WF_OBTYPE, &a, &b, &c, &d) - a = object type of decoration "n"
  wind_get(n, WF_OBSPEC, &a, &b, &c, &d) - (b<<16)|a = spec of decoration "n"
  wind_set(n, WF_OBFLAG,  a,  b,  c,  d) - Set flags for decoration "n" to "a"
  wind_set(n, WF_OBSPEC,  a,  b,  c,  d) - Set spec of decoration "n" to
                                           (b<<16)|a

  The "n" parameter is one of:

#define W_BOX            0  outline
#define W_TITLE	         1  titlebar outline
#define W_CLOSER         2  close box
#define W_NAME	         3  titlebar
#define W_FULLER         4  full-size box
#define W_INFO           5  info bar
#define W_DATA	         6  work area outline
#define W_WORK	         7  work area
#define W_SIZER	         8  resize box
#define W_VBAR           9  vertical scroll bar outline
#define W_UPARROW       10  scroll up box
#define W_DNARROW       11  scroll down box
#define W_VSLIDE        12  vertical scroll bar
#define W_VELEV	        13  scroll thumb
#define W_HBAR          14  horizontal scroll bar outline
#define W_LFARROW       15  scroll left box
#define W_RTARROW       16  scroll right box
#define W_HSLIDE        17  horizontal scroll bar
#define W_HELEV	        18  horizontal scroll bar thumb

FreeGEM: Extended 3D
====================

  FreeGEM implements an extended 3D controls system, similar to that in GEM/5.
This system works by overloading the WHITEBAK and DRAW3D flags; it is
therefore incompatible with Atari GEM, which overloads WHITEBAK differently.
If the ABLE_X3D bit is set in the AES abilities field, then the following
features are available:

* Checkboxes. Set the DRAW3D state and the SELECTABLE flag on a 2-dimensional
             object such as a G_STRING.

* Radio buttons. Set the RBUTTON flag on a checkbox.

    By default, checkboxes and radio buttons display as if on a 3D background.
  Set the WHITEBAK state to make them display correctly on a white background.

* Default buttons. Set the DEFAULT state and the DRAW3D flag on a G_BUTTON
 object, and a <=" symbol will appear on it.

* Sunken 3D objects. Set the FL3DBAK flag on them rather than FLAG3D, and
 the object will be drawn sunken.

* Ability to set 3D light/dark colours, tick and dot colours using
 xgrf_colour().

* 3D objects with no black border - set the WHITEBAK flag. 

FreeGEM and GEM/4: 32 drives
============================

  GEM/4, GEM/5 and recent FreeGEM builds support 32 disc drives rather than
16. The function to do this is present on FreeGEM if the ABLE_XBVSET bit is
set in the "abilities" bitmap.
  To retrieve or change the drive bitmaps, use appl_xbvget and appl_xbvset:

WORD appl_xbvget(ULONG *bvdisk, ULONG *bvhard);
    This will return the two 32-bit drive vectors, with bit 31 indicating
   drive A: and bit 6 indicating drive Z:.
WORD appl_xbvset(ULONG bvdisk, ULONG bvhard);
    This sets the drive vectors, as above.

USERDEF objects
===============

  In the first version of the library, the programmer had to supply
their own "glue" code in assembly language in order to implement USERDEF
objects. This code has now been moved into the library.

  To set up a USERDEF object, use the following call:

  VOID ppd_userdef(LPTREE tree, WORD nobj, LPPBLK ub);

  The first two parameters define the object in which you are interested. The
third points to a structure of type PPDUBLK; you must use this instead of
the USERBLK or APPLBLK structures. It has ub_code and ub_parm members, as
if it were a USERBLK.

  The ppd_userdef() function sets the type of the object to G_USERDEF, and
initialises the reserved members in the PPDUBLK. By the time your code is
called, the pb_parm member (in the PARMBLK it is passed) will be the ub_parm
you supplied.

Hooking the AES or VDI
======================

  The libraries now include two methods for diverting calls to the AES or VDI.

  The first method catches only those calls made by your program. To use it,
make one or both of these calls:

  AESFUNC divert_aes(AESFUNC new)
  VDIFUNC divert_vdi(VDIFUNC new)

  The divert_* functions return the address of the previous override function,
or NULL if there was none. If the parameter passed is NULL, the default
functions will be used.
  Your new handlers must make their own INT 0xEF calls. They should not
call the library AES or VDI functions, since the library is not reentrant.

  The second method allows a program (normally a DA) to inspect and modify
all calls to GEM, except those made by the program itself. It should call:

  ppd_hookon(AESFUNC newaes, AESFUNC new201, VDIFUNC newvdi);

where:

  newaes   is your handler for calls to the AES with CX=200.
  new201   is your handler for calls to the AES with CX=201. This should
           normally be left as NULL, as it has no effect in single-tasking
           versions of GEM.
  newvdi   is your handler for VDI calls.

  You can leave any of these as NULL if you don't want to write a special
handler for them.

  Your AES or VDI handler should return:

1: To pass the call through to the appropriate part of GEM.
0: If the call was handled by your code.

IMPORTANT: If your code made any calls to the AES or the VDI, then it must
          return 0. If it is necessary that your code should do something and
          then call the original handler, then call it explicitly before
          returning 0.

  The function   ppd_setresult(WORD w)   sets the value to be returned in AX
from your code. This is only effective if your code returned 0.

  GEM calls made by your program will not be intercepted by its hook
function; this is to avoid problems of reentrancy. This means that if
you have overridden both the AES and the VDI, your VDI handler will not
intercept any calls made by your AES handler, or calls resulting from them.
Neither handler will intercept calls made from other parts of the same
program.

  An example of this type of hook is GROWBOX.C, which uses ppd_hookon() to
add extra commands (graf_growbox() and graf_shrinkbox()) to the AES.

  If you are using these commands in an application, it is very important
to call ppd_hookoff() before termination. DAs do not terminate until GEM
does, so there is no need to call ppd_hookoff().

Recent new features:
===================

* Support for the GEM/4 function to get/set 32-bit vectors of available
 disc drives. This function has been given two bindings: appl_xbvget()
 and appl_xbvset().

* Bug fixes in dos_read() and dos_write().
* Support for xshl_getshell() and xshl_setshell().
* vqt_name() returns an empty string if called for font 1 on GEM/5. This
 is a useful test that GEM/5 is present.

* Support for extended 3D objects.

* Support for extended wind_set() and wind_get().

* Support for xapp_getinfo().

* Support for the prop_*() functions in FreeGEM:

  WORD prop_get(LPBYTE program, LPBYTE section, LPBYTE buf, WORD buflen,
                WORD options);
  WORD prop_put(LPBYTE program, LPBYTE section, LPBYTE buf, WORD options);
  WORD prop_del(LPBYTE program, LPBYTE section, WORD options);

* DEMO has been rewritten to take advantage of the prop_*() functions in
 FreeGEM.

* DEMO has been rewritten to illustrate how to detect FreeGEM; if it
 does detect it, it uses fsel_exinput() instead of fsel_input(). It also
 prints the AES build string in the "About" box.

* The additional samples from the GEM 3.1 PTK have been added.

* The additional GEM 3.1 libraries XFMLIB, OBLIB, RCLIB and EMSLIB have
 been incorporated into the library.

* The following extra bindings from the GEM 3.1 PTK are present:

VOID v_ps_halftone(WORD handle, WORD index, WORD angle, WORD frequency);
WORD shel_get(BYTE FAR *pbuffer, WORD len);
WORD shel_put(BYTE FAR *pbuffer, WORD len);
VOID v_setrgbi(WORD handle, WORD primtype, WORD r, WORD g, WORD b, WORD i);
VOID v_topbot(WORD handle, WORD height, WORD FAR *char_width, 
                 WORD FAR *char_height, WORD FAR *cell_width, 
                 WORD FAR *cell_height);
VOID vs_bkcolor(WORD handle, WORD color);
VOID v_set_app_buff(LPVOID address, WORD nparagraphs);
WORD v_bez_on(WORD handle);
WORD v_bez_off(WORD handle);
WORD v_bez_qual(WORD handle, WORD prcnt);
VOID v_pat_rotate(WORD handle, WORD angle);
VOID vs_grayoverride(WORD handle, WORD grayval);
VOID v_bez(WORD handle, WORD count, LPWORD xyarr, UBYTE FAR *bezarr, 
           LPWORD minmax, LPWORD npts, LPWORD nmove);
VOID v_bezfill(WORD handle, WORD count, LPWORD xyarr, UBYTE FAR *bezarr, 
               LPWORD minmax, LPWORD npts, LPWORD nmove);


