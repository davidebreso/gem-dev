Porting the GEM Developers' Kit to Open Watcom - Davide Bresolin, January 2022
==============================================================================

My work on the Open Watcom port of the GEM Developer'k kit started from John 
Elliott's GDK for Pacific C <http://www.seasip.info/Gem/devkit.html>. 

John and the people of the FreeGEM team already did the heavy lifting of 
porting and updating Digital Research GEM source code to a more modern compiler, 
so I started from a source code that worked out-of-the box for most of the 
functionalities and examples. Version 1.0 of the GDK was ready with a few hours
of work and could generate working sample applications, with four exceptions:

 * Desktop Accessories compiles correctly but the executable didn't work;
 * USERDEF objects were not supported;
 * hooking the AES or VDI didn't work;
 * the RSCREATE example generated incorrect resource files.

This document keeps track of how I was able to solve the problems of the first 
port of the GDK, and to obtain a version that is almost identical to the Pacific 
C Developer's kit from the point of view of the application programmer, but 
allow to use a modern environment for writing and compiling the code.

Far pointers
============

In the original Lattice C libraries of the GEM PTS, all far pointers were cast
to long integers. The Pacific C libraries replaced them with true far pointer types, created using typedefs. 

These types are available in the Open Watcom library, and this means that a lot
of structure accesses and pointer arithmetic can be delegated to the compiler. 

If you are working in the "small" memory model, problems may occur when you are
passing a local address to a routine requiring a far pointer, or a far pointer 
to a routine requiring a near address.

The Open Watcom compiler seems to be able to solve most of the issues that arise 
when mixing pointer types automatically. It can expand correctly a near pointer 
to a long address in many cases, and it emits warnings when an address is 
truncated or there is a pointer type mismatch. 

This means that the ADDR() macro used by the Pacific C library to expand a near 
pointer is not needed in the majority of the situations. It is included in the 
library to ease porting from Pacific C code and to cover the few cases where it is needed.

Memory models
=============

Open Watcom handles "small", "compact", "medium", "large" and "huge" memory
models. This package is configure to build only the "small" and "large" models.
There are optional targets in libsrc/Makefile to build the library for the other
models when needed. 

In the "small" and "medium" memory models C library functions can be used only
on near pointers. However, the Open Watcom library includes "data model independent forms" for some of the C library functions that accepts far pointer 
arguments and returns far pointers and that can be used in any memory model.

Sample Applications
===================

The directory samples/ contains Open Watcom ports of the GEM PTK sample
applications. The main() function simply checks for the GEM AES before calling GEMAIN().

  The original GDK documentation states:

     3 - To link a GEM application (not a GEM accessory), you may use
     the startup program and library supplied by your compiler,  if you
     know that your compiler generates code to free memory not used by
     your program.

From my examination of the startup code, it seems that Open Watcom generates the 
code to free unused memory, as requested by the GDK documentation. All sample
applications required only minimal changes to the code to work, with the exception of RSCREATE. You can find some notes on how RSCREATE works on Open Watcom in the document samples/rscreate/readme.txt.

Building Desktop Accessories
============================

Building Desktop Accessories it's a different story, as they are one of the few 
cases where I have to change diverge from the approach used in the Pacific C
library. GEM allocates memory for desk accessories based on the size of the DA 
file, and then jumps to offset 0 of the accessory code segment to start the 
accessory. In contrast, an application generated by Open Watcom:

 * starts the execution from an address that is never 0. The code at offset 0 is
   an infinite loop of INT 3.
 * the executable file includes only the code and the initialised data.   
   Uninitialised data and the stack are not included in the executable file.
   
To compile and link desktop accessories that can be executed by GEM, I included
a custom startup code stub (accstart.asm) in the sample/directory. The startup 
code starts at offset 0 of the special segment BEGTEXT, that is always the first
segment of the executable file generated by WLINK. It allocates initialised data
in the STACK segment, to increase the size of the DA file linked by Open Watcom
so that it has sufficient memory available to it, and puts the stack pointer 
where it should be. With this startup code the size of the stack is not 
determined by the linker, but by the assembly-time text macro STACKSIZ.

With this approach a Desktop Accessory can be compiled as a normal GEM
application, and then linked with the

    libfile start-s.obj (small model)
or  libfile start-l.obj (large model)

WLINK directive to replace Open Watcom's startup code with the custom stub. 

USERDEF objects
===============

User-defined objects allow the programmer to define a custom routine to draw and/or change an object. The argument of the routine is a PARMBLK structure
that is passed by GEM in the register pair AX:BX, and expects the return value
of the routine to be in AX. Open Watcom allows to define the calling convention
of routines using auxiliary pragmas as in the following example, that defines a
function _far_draw with two 2-byte arguments in AX and BX and a 2-byte return
value in AX:

WORD _far_draw(WORD seg, WORD ofs);
#pragma aux _far_draw parm [AX] [BX] value [AX]

The auxiliary pragma solved the problem of getting the PARMBLK address from GEM. 
However, to get a working custom routine I had to face another problem. Open 
Watcom assumes that the stack is in the data segment DGROUP of the application. 
Since the custom drawing routine is executed directly by GEM and not by the application, the stack pointer is outside of DGROUP when the routine is called. 
There is a compiler option that removes the assumption on the position of the 
stack. However, with this option enabled variables allocated on the stack became 
far variables when passed to other functions. This caused problems with 
truncated pointers for "small" model builds, and produced "large" model builds 
that compiled correctly but didn't work.

The current version of the library uses some "glue" code in assembly to implement USERDEFS objects. This code takes care of getting the PARBLK address
from GEM and setting the stack pointers and data segments to the correct values.
To avoid corruption of the application stack, the code uses a separate memory 
area for the stack of the user-defined routine. This area is allocated by the
library and has a default size of 1024 bytes, that should be enough for most of 
the cases. If you need to change this value you have to change

#define NEWSTACK_SIZ 1024

in wccfdraw.c, and then recompile the library. 

To set up a USERDEF object, you can proceed as in the Pacific C library and
use the call:

  VOID wcc_userdef(LPTREE tree, WORD nobj, LPPBLK ub);

The first two parameters define the object in which you are interested. The
third points to a structure of type WCCUBLK; you must use this instead of
the USERBLK or APPLBLK structures. It has ub_code and ub_parm members, as
if it were a USERBLK.

The wcc_userdef() function sets the type of the object to G_USERDEF, and
initialises the reserved members in the PPDUBLK. By the time your code is
called, the pb_parm member (in the PARMBLK it is passed) will be the ub_parm
you supplied.

Hooking the AES or VDI
======================

The libraries include the two methods for diverting calls to the AES or VDI 
introduced in the Pacific C libraries.

The first method catches only those calls made by your program. To use it,
make one or both of these calls:

  AESFUNC divert_aes(AESFUNC new)
  VDIFUNC divert_vdi(VDIFUNC new)

The divert_* functions return the address of the previous override function,
or NULL if there was none. If the parameter passed is NULL, the default
functions will be used. Your new handlers must make their own INT 0xEF calls. They should not call the library AES or VDI functions, since the library is not reentrant.

The second method allows a program (normally a DA) to inspect and modify all 
calls to GEM, except those made by the program itself. It should call

  wcc_hookon(AESFUNC newaes, AESFUNC new201, VDIFUNC newvdi);

to set-up the hook. Please refer to the original documentation of Pacific C 
libraries in doc/ppd.doc for the details on the parameters of the call and 
how to write your AES or VDI handler.

To write the code to hook the AES and VDI I had to face the same problem with 
the stack placement of user-defined drawing routines. I solved it with the very
same approach of reserve a separate memory area for the stack of the AES/VDI
handlers. To avoid any possible corruption, this area is different from the 
standard stack of the application an for the custom stack for USERDEF objects.
The AES/VDI hook stack has a default size of 1024 bytes. If you want to change 
its size you have to change

#define NEWSTACK_SIZ 1024

in wcchook.c, and then recompile the library. 

New features
============

The libraries includes all new features added by John Elliott to the Pacific C libraries. Please refer to doc/ppd.doc for a complete description of the new 
features.

